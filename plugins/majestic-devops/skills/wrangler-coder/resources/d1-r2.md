# D1 Database & R2 Storage

## D1 Database

### Configuration

```toml
name = "my-worker"
main = "src/index.ts"
compatibility_date = "2024-12-01"

[[d1_databases]]
binding = "DB"
database_name = "my-database"
database_id = "your-database-id"
```

### CLI Commands

```bash
# Create database
wrangler d1 create my-database

# List databases
wrangler d1 list

# Execute SQL
wrangler d1 execute my-database --command "SELECT * FROM users"
wrangler d1 execute my-database --file ./schema.sql

# Local development (uses local SQLite)
wrangler d1 execute my-database --local --command "SELECT * FROM users"

# Export database
wrangler d1 export my-database --output backup.sql

# Migrations
wrangler d1 migrations create my-database "add_users_table"
wrangler d1 migrations apply my-database
wrangler d1 migrations apply my-database --local  # Local dev
```

### Migrations

```
migrations/
├── 0001_create_users.sql
├── 0002_add_posts.sql
└── 0003_add_indexes.sql
```

```sql
-- migrations/0001_create_users.sql
CREATE TABLE IF NOT EXISTS users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  email TEXT UNIQUE NOT NULL,
  name TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_users_email ON users(email);
```

### Usage in Worker

```typescript
export interface Env {
  DB: D1Database;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Query
    const { results } = await env.DB.prepare(
      "SELECT * FROM users WHERE id = ?"
    ).bind(1).all();

    // Insert
    const result = await env.DB.prepare(
      "INSERT INTO users (email, name) VALUES (?, ?)"
    ).bind("user@example.com", "John").run();

    // Batch operations
    const batch = await env.DB.batch([
      env.DB.prepare("INSERT INTO users (email) VALUES (?)").bind("a@example.com"),
      env.DB.prepare("INSERT INTO users (email) VALUES (?)").bind("b@example.com"),
    ]);

    return Response.json({ users: results });
  }
};
```

## R2 Storage

### Configuration

```toml
name = "my-worker"
main = "src/index.ts"
compatibility_date = "2024-12-01"

[[r2_buckets]]
binding = "BUCKET"
bucket_name = "my-bucket"
preview_bucket_name = "my-bucket-preview"  # For wrangler dev
```

### CLI Commands

```bash
# Create bucket
wrangler r2 bucket create my-bucket

# List buckets
wrangler r2 bucket list

# Object operations
wrangler r2 object put my-bucket/path/to/file.txt --file ./local-file.txt
wrangler r2 object get my-bucket/path/to/file.txt
wrangler r2 object delete my-bucket/path/to/file.txt

# List objects
wrangler r2 object list my-bucket --prefix "uploads/"
```

### Usage in Worker

```typescript
export interface Env {
  BUCKET: R2Bucket;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    const key = url.pathname.slice(1);

    switch (request.method) {
      case "GET": {
        const object = await env.BUCKET.get(key);
        if (!object) return new Response("Not found", { status: 404 });

        return new Response(object.body, {
          headers: {
            "Content-Type": object.httpMetadata?.contentType || "application/octet-stream",
            "ETag": object.httpEtag,
          }
        });
      }

      case "PUT": {
        await env.BUCKET.put(key, request.body, {
          httpMetadata: {
            contentType: request.headers.get("Content-Type") || "application/octet-stream",
          }
        });
        return new Response("Created", { status: 201 });
      }

      case "DELETE": {
        await env.BUCKET.delete(key);
        return new Response("Deleted", { status: 200 });
      }
    }

    return new Response("Method not allowed", { status: 405 });
  }
};
```
